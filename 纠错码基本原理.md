## ECC机制
**错误方式**：3D NAND闪存每种状态的阈值电压分布发生偏移，由于移动和加宽，不同状态的阈值电压分布开始重叠，读取的参考电压不再能够正确识别重叠区域中某些闪存单元的状态，从而导致读取错误。 

ECC在数据信息里添加了冗余项，于是读取时可以借助进行错误检测并将数据信息恢复成最接近写入时的样子，加入了冗余项的编码数据通常被称为码字。

**分类**：BCH和LDPC

$A$代表码字大小，与其对应的由码率的概念。

原始误码率：
$$
RBER = \frac{\text{Number of bit errors}}{\text{Total number of bits}}
$$
错误率FER(Frame Error Rate)：
$$
FER = 1 - \left[ \left(1 - RBER\right)^{A} + \binom{A}{1} RBER \left(1 - RBER\right)^{A-1} + \ldots + \binom{A}{t} RBER^t \left(1 - RBER\right)^{A-t} \right]
$$

其中$\binom{A}{m} RBER^m(1 - RBER)^{A-m}$表示有m个比特发生错误，而错误数大于t时无法纠正，产生总体的不可修复错误。

不可修复误码率:
$$UBER=\frac{FER}{A}$$

### 硬判决和软判决
**硬判决**：用数字方式处理所有的数据，即“0”或“1"，模拟信息通过使用一个固定的参考电压被转换为数字格式。

**软判决**：使用可靠性来做出决定：例如，一个数据读为“0”有90%的概率，而读为“1”的概率为10%，则判决为“1”。**3D NAND闪存使用的是软判决码。**

码C是一组码字集合，它通过一种明确的方式将空间A中$k^q$个长度为$k$的信息关联到空间B中$k^q$个长度为$n$的码字。 **若给定两个码字，和仍是一个码字，则该码为线性的，此时该码的编码和解码过程可以用矩阵运算来描述。** 

将编码C的生成矩阵定义为G，所有的码字都可以通过矩阵G的行元素的组合而获得。因此，编码一个数据信息m相当于下式那样，将信息m乘以码生成矩阵G。 
$$c=m\cdot G$$

如果 $G = \left( I_k , P \right)$，这里 $I_k$ 是单位矩阵 $k \times k$，$P$ 是矩阵 $k \times (n-k)$，则 $G$ 被称为标准式或系统形式。如果 $G$ 是标准形式，一个码字的开始 $k$ 个符号被称为信息符号。根据系统形式的矩阵 $G$，可以直接得出校验矩阵 $H = \left(-P^T, I_{n-k} \right)$，其中 $P^T$ 是 $P$ 的转置，它是 $(n-k) \times k$ 的矩阵，$I_{n-k}$ 是 $(n-k) \times (n-k)$ 的单位矩阵。系统码优点在于数据消息可以在码字中清楚地识别出来，因此它可以在解码之前读取。对于非系统码，消息在编码序列中不能被识别，并且需要具有逆编码功能来识别数据序列。

若 $C$ 是具有校验矩阵 $H$ 的线性码，则 $x \cdot H^T$ 称为 $x$ 的校验子。于是所以码字的校验子都等于 $0$。校验子是解码的关键因素，一旦收到消息 $r$ （即从存储器中读取），有必要了解它是否已被破坏，通过下面计算：
$$s = x \cdot H^T$$
若$s=0$，则接受消息r正确，否则包含错误。

错误时，解码过程开始，为了知道可以纠正或检测一个码字有多少错误，编码理论中定义了码的最小距离为度量标准，它对应于两个码字之间不同符号的最小个数。一种码能够识别出最多v个错误的全部信息，则称它具有检测能力V。检测能力与下式描述的最小距离有关。 
$$v=d-1$$
若能够纠正最多 $t$ 个错误的每种组合情况，则该码具有纠错能力 $t$，这个纠错能力由最小距离 $d$ 计算，如下式所示。
 $$t=[ \frac{d-1}{2}]$$

其中方括号代表着下取整函数。
## BCH码
BCH码属于循环代数码，在构造时就可以确定它的最小距离

BCH码属于循环代码，构造时就可以确定它的最小距离，该码本身的定义是基于距离的概念和伽罗瓦域。令 $\beta$ 是伽罗瓦域 $GF(q^m)$ 的元素，令 $b$ 为负整数。具有汉明距离 $d$ 的 BCH 码由最小多项式 $g(x)$ 生成，多项式的根为 $d$-1 个连续的 $\beta$ 的幂：$\beta^b$，$\beta^{b+1}$，…，$\beta^{b+d-2}$。令 $\psi_i$ 是 $\beta^{b+i}$ 的最小多项式，$0 \le i < d - 1$，则 $g(x)$ 按照下面计算，而且被保护的数据是 $k=n-deg(g(x))$。

$$ g\left(x\right)=LCM\left\{\psi_0\left(x\right),\psi_1\left(x\right),\cdots,\psi_{d-2}\left(x\right)\right\} \tag{5.8} $$

$d$ 至少是 $2t+1$，该码至少可以纠正 $t$ 个错误。假设 $b=1$，并且 $\beta$ 是 $GF(q^m)$ 的本单元，则该码成为狭义的原始 BCH 码，它的长度为 $q^m-1$，且能纠正 $t$ 个错误。BCH 码的通用的结构如下图。

<img src="./pic/纠错码/BCH结构.png">

### BCH编码
假设一个 BCH 码 [n, k] 具有多项式 $g(x)$ 和一个要被编码的消息 $m(x)$，该消息被写为 $k$-1 次的多项式。首先，根据式（5.9）及式（5.10），获得商 $q(x)$ 和余数 $r(x)$。
$$ \frac{m(x)\cdot x^{n-k}}{g(x)} = q(x)+\frac{r(x)}{g(x)} \tag{5.9} $$
$$ m(x)\cdot x^{n-k} + r(x) = q(x)\cdot g(x) \tag{5.10} $$
式中 $m(x)\cdot x^{n-k}$ 的结果产生了 $n$-1 次多项式，其中开头的 $n-k$ 个系数（现在为零）将由奇偶校验位占用。因此编码码字 $c(x)$ 如下计算：
$$ c(x)=m(x)\cdot x^{n-k}+r(x) \tag{5.11} $$

式（5.11）的实际实现方式如下图所示，因为考虑的是二进制 BCH 码，求和实际是一个 XOR，输出结果是一个 AND。

BCH 编码的结构是顺序的，这对于高速实现并不利，因为它慢慢以节、字或双字的方式进行处理。图（b）显示了展开的实现，假设处理为 1 次 1 字节。在图中可以看到每个寄存器的内容不再依赖于单个输入，而是整个字节。

<img src="./pic/纠错码/BCH除法器_1.png">
<img src="./pic/纠错码/BCH除法器_2.png">

### BCH译码

## LDPC码
LDPC (Low Density Parity Check，低密度奇偶检查码) 码可以被视为一种特定的ECC技术，它通过构建稀疏的检验矩阵实现纠错。

## 极化码